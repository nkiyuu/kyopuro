# 2-5 あれもこれも実はグラフ

## 無効グラフと有効グラフ

### 木について

辺の数 = 頂点数 - 1 の連結グラフ ↔︎ 木
が成り立つ

### 有効グラフ

DAG (Directed Acyclic Graph)
有効グラフで閉路をもたないグラフ

#### トポロジカル順序
Vi から Vj への変がある時、常に i < j が成り立つ番号の付け方
DP が使えるようになることもある

トポロジカルソート
トポロジカル順序を求めること
DAG は必ずトポロジカル順序にできる

#### ベルマンフォート法

単一始点最短路問題でつかえる
頂点集合を V, 辺集合を E とすると、O(|V||E|) の計算量

始点　s から頂点 i への距離を d[i] とする。このとき、以下の等式が成り立つ。
d[i] = min{d[j] + (jからiへの辺のコスト) | e=(j,i) ∈ E}
負の経路がない場合には、|V-1| の回数のループで実現可能。
|V| のループが発生することを考えると負の閉路の存在の検出にも使える

#### ダイクストラ法

単一始点際短絡問題で使える
ベルマンフォード方よりも計算効率は良い。
負の経路が存在する場合には使えない。

1. 最短距離が確定した頂点と隣接している頂点を更新する。
2. 1.で使った「最短距離が確定した頂点」は考慮しない

「際短距離が確定した頂点」は更新の中で最短距離となるパスで到達できる頂点になる。
他のパスについては暫定的な値として、まだ更新中としとく。
隣接行列や隣接リストを用いた実装だと O(|V|**2) になってしまう。
ヒープやプライオリティキューをつかうことにより O(|E|log|V|) まで落とすことができる。

蟻本では、仮の最小距離とその頂点を Pair で管理するようにしてた
priority queue で実装していたが、comp に Pair を入れてその 1st で比較するみたいなことができるっぽい。便利。

#### ワーシャル-フロイド法

全点対最短路問題でつかう
全ての２頂点間の最短路を求める問題で有用だぜ

基本的な考えは、最短路を求めたい２点にたいして各頂点を経由点として、最短路になるかを比較していく
0 ~ k の頂点を差し込んでいく時、k-1 のまでは最小値であることが保証されているので、k を経由するかどうかを調べるだけでよい

#### 最小全域木

連結で閉路を持たない木のことを全域木という。
辺にコストがある場合に、使われる辺のコストが最小になるように作られた全域木を最小全域木（MST: Minimum Spanning Tree）と呼ぶ。

MST を求めるには以下の２つのアルゴリズムがある

* プリム法
* クラスカル法

##### プリム法

ダイクストラ法と似た感じで、ある頂点から始めて最小の辺を足していく手法。
証明は省略するけど、貪欲に最小の辺を考慮していくことにより構築ができる。

##### クラスカル法

辺をコストの小さい順に見ていって、閉路がなければ追加するという手順をとる。